## 순회 뽑기

### 문제 설명

- 링크드리스트 구조의 배열을 순회하면서, K번째 요소를 삭제합니다.
- 요소를 삭제할때마다 배열의 전체크기가 감소합니다.

### 자료 구조

- **arr**
  - 타입 : 리스트
  - 저장 데이터 : 인덱스+1
- **answer**
  - 타입 : 리스트
  - 저장 데이터 :  뽑힌 요소
- **k**
  - 타입: number
  - 저장데이터: 순회를 시작하는 시작 인덱스
- **idx**
  - 타입: number
  - 저장데이터: 실제 순회를 할때 쓸 인덱스 (k-1 을 해야함)

### 풀이 과정

```txt
1. 먼저 순회를 시작할 인덱스(idx)를, k-1로 지정합니다.
		1-1. 이후 idx를 업데이트시켜가면서, 순회를 할 것입니다.
		
2. idx 위치의 요소를 삭제하고, idx를 업데이트 합니다.
		2-1 *중요: idx 위치의 요소를 삭제한뒤에는, 배열의 크기가 -1 되므로, 요소를 삭제한 직후, idx-- 를 수행해야 합니다.
		2-2 다음 삭제할 idx의 위치는, idx = (idx+k)%len(arr) 가 됩니다.
		
4. 배열에 하나의 숫자만 남게되면, 반복문을 탈출하게되고,
 arr[0] 를 통해 직접 숫자를 뽑습니다.
```



### 시간복잡도

O(N)

### 코드 구현

- 사용 언어 : 파이썬

```python
n, k = map(int, input().split())

arr = [0] * n
answer = []

for i in range(n):
    arr[i] = i + 1
idx = k - 1  #1: 초기 인덱스 설정.

while len(arr) > 1: #4 하나의 숫자만 남을때,탈출
    answer.append(arr[idx]) # 뽑을 요소를 정답배열에 옮깁니다.
    del arr[idx] #2: idx위치의 요소를 삭제
    idx -=1 # 2-1: idx위치의 요소를 삭제하면 뒤에있던 요소가 앞으로 당겨지니까, idx--를 통해서 돌아가주어야함
    idx = (idx+k)%len(arr) # 2-2  현재인덱스+k) % 배열의 길이 의 나머지가 , 다음 위치입니다

answer.append(arr[0]) 
for x in answer:
    print(x, end=" ")

```

- 점수 : 100점 / 100점