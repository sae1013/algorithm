## 1766 

### 문제 설명

- 문제의 조건이 있습니다. 첫째는 우선순위 이고, 둘째는 쉬운문제 입니다.

  이것을 그래프 문제로 대입하면, 노드간의 우선순위 관계를 의미하는 위상정렬로 해결할 수 있습니다.

  즉, 우선순위가 빠른것부터 해결해야하니, 우선순위 요소는 depth가 0이고

  그다음 풀어아할 문제(b)는 depth가 1 이됩니다. 

  둘째 조건을 만족하기위해, 최소힙을 사용하면, 우선순위를 1순위로, 쉬운문제를 2순위로 조건을 거를 수 있습니다

### 자료 구조

- **depth**
  - 타입 : 리스트
  - 저장 데이터 : 문제번호의 depth(우선순위)를 저장
- **graph**
  - 타입 : 리스트
  - 저장 데이터 : 그래프의 연결관계를 나타내는 2차원 배열
- **pq**
  - 타입: 최소힙
  - 저장데이터: 문제번호(노드번호)

### 풀이 과정 

```txt
1. 문제의 조건에서 문제순서는 다음과 같습니다.
	1-1. 우선순위
	1-2. 쉬운문제
  만약 4 2 / 3 1 의 입력을 해석해보면, 4번 문제후에 2번문제를 해야하고, 3번문제후에 1번을 해야한다는 의미입니다.
  따라서 depth[2] +=1, depth[1]+=1 을 수행합니다.
  4번 노드와 3번노드는 depth가 0 으로써, 4와 3은 동일한 우선순위를 같습니다. 여기서 문제의 2번째조건. 쉬운문제먼저 수행하기위해, 최소힙을 사용합니다.
  
  2. 위상정렬을 수행합니다.
  2-1 가장먼저, depth 배열을 순회하면서 depth가 0 인 (우선수위가 가장높은) 문제번호들을 최소힙에 삽입합니다. 
  2-2 최소힙이 빌때 까지 while문을 반복할 것입니다.
  2-3 최소힙에서 수를 하나 뽑습니다. 우선순위가 가장높으면서, 가장쉬운문제의 문제번호가 나옵니다.
  2-4. 해당 문제번호의 그래프 배열을 확인합니다. 해당 문제번호와 연결된 노드들의 depth를 1씩 줄여줍니다.
  만약 연결된 노드의 depth가 0 이된다면, 이제 우선순위차례가 되었음을 의미하므로, 최소힙에 넣어줍니다.
  

```

### 시간복잡도

O(N)



### 코드 구현

- 사용 언어 : 파이썬

```python
import heapq

def poly(): # 위상정렬
	pq = []
	for i in range(1,n+1): #1번노드~n번노드까지 depth를 검사
		if depth[i] == 0:
			heapq.heappush(pq,i)
			
	while pq :
		k = heapq.heappop(pq)
		print(k,end = " ") 
		for next_node in graph[k]:
			depth[next_node] -=1
			if depth[next_node] == 0:
				heapq.heappush(pq,next_node)
		
n,m = map(int,input().split())
depth = [0]* (n+1)
graph = [[] for _ in range(n+1)] # [ [],[],[],[]... ]

for i in range(m):
	a,b = map(int,input().split())
	graph[a].append(b)
	depth[b] +=1
poly()

```

- 점수 : 100점 / 100점
