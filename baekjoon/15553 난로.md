## 15553 난로

### 문제 설명

-  제한된 성냥의 갯수를 이용해서 난로를 켜야하는데, 난로를 켜는 지속시간을 가장 최소로 하도록 하여야합니다.

### 자료 구조

- **arr**
  - 타입 :  리스트
  - 저장 데이터 : 친구가 도착 하는 시간 
- **diff**
  - 타입 : 리스트
  - 저장 데이터 :  친구가 도착하는 시간들 사이의 간격

### 풀이 과정

```txt
1. 친구가 도착하는 시간들간의 간격을 구합니다.
	1-1 간격을 담은 배열 diff를 내림차순으로 정렬합니다 (성냥의 갯수를 효율적으로 사용하기위해)
	1-2 즉, 가장 긴 구간에서 성냥을 사용하도록 합니다. 성냥의 갯수가 k개 이므로, 정렬된 diff에서, k-1개를 지울 수 있습니다.(가장최초에 1개는 필수이므로, 여분의 성냥은 k-1개가 된다)
 
 2.이후에 diff에 남은 간격들을 모두 더한다음, +1 을 더하면 최초 난로를 켠다음 유지되는 총 시간이 구해집니다.(가장 긴구간은 제외하고)
 	2-1. 가장 긴 구간은, k-1개의 성냥을 사용했으므로, 위에서 구한 총 시간에, k-1 만큼의 시간을 더해야합니다.
```



### 시간복잡도

O(N)

### 코드 구현

- 사용 언어 : 파이썬

```python
n, k = map(int,input().split())
arr = []
diff = []
for i in range(n):
	arr.append(int(input()))
for i in range(1,n):
	diff.append(arr[i]-arr[i-1])

diff = sorted(diff,key = lambda x : -x) # 구간길이를 내림차순정렬.

# k-1만큼 구간을 지울 수 있다.즉 가장 긴구간에서는 해당부분에서만 성냥을 켜도록 한다.
ans = diff[k-1:] # 내림차순 정렬됐으므로, k-1번째 요소부터, 모든 요소(구간의 길이)를 더한다.

print(sum(ans)+1+k)  # sum(ans)+1+k-1 
#sum(ans)+1은, 성냥이 부족해서 이어져있는 구간에 한번에 불을켰을때 난로 켜져있는 시간을 의미
#k-1은, 독립적으로 성냥을 켰을 때 난로가 켜져있는시간을 의미.

```
