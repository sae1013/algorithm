```python
### 시간복잡도 O(NM)

벽부수고 이동하기 .
3차원배열로, 0->1로 넘어가면 그이후에는 1->0 으로 넘어오지못함.
방문할때 0->1 과 0->0 두부분을 방문한다.
3차원 배열을 통해 해결하는 재밌는 문제군
from collections import deque

def bfs(y,x,z):
    q = deque()
    dy = [0, -1, 0, 1]
    dx = [-1, 0, 1, 0]
    visit[z][y][x] = 1
    q.append([y,x,z])
    while q:
        y, x, z = q.popleft()
        for i in range(4):
            ny = y+dy[i]
            nx = x+dx[i]
            if z== 0:
                if 0<=ny<n and 0<=nx<m and board[ny][nx] == "0" and visit[z][ny][nx] ==0 :
                    visit[z][ny][nx] = 1
                    dp[z][ny][nx] = dp[z][y][x]+1
                    q.append([ny,nx,z])
                elif 0<=ny<n and 0<=nx<m and board[ny][nx] == "1" and visit[z+1][ny][nx]==0:

                    visit[z+1][ny][nx] = 1
                    dp[z+1][ny][nx] = dp[z][y][x]+1
                    q.append([ny,nx,z+1])

            elif z == 1: #
                if 0 <= ny < n and 0 <= nx < m and board[ny][nx] == "0" and visit[z][ny][nx] == 0:
                    visit[z][ny][nx] = 1
                    dp[z][ny][nx] = dp[z][y][x] + 1
                    q.append([ny,nx,z])


n,m = map(int,input().split())
board = [input() for _ in range(n)]
visit = [[[0]*m for _ in range(n)] for _ in range(2)] # 3차원 배열
dp = [[[-1]*m for _ in range(n)] for _ in range(2)] # 3차원 배열
dp[0][0][0] = 1

bfs(0,0,0)
ans = min(dp[0][n-1][m-1],dp[1][n-1][m-1])
if ans == -1 :
    print(max(dp[0][n-1][m-1],dp[1][n-1][m-1]))
else:
    print(min(dp[0][n-1][m-1],dp[1][n-1][m-1]))


```